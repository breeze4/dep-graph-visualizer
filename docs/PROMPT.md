I am building a tool to help me plan the rearchitecture/refactoring of an angular monorepo codebase. Basically in the target codebase there is an apps dir with a couple SPA, but one primary app called dashboard. Then there is a bunch of libraries in a libs/. There are no real strong interfaces, just collections of code. Many services and various components. Now I want to create a tool to help me identify tightly coupled and loosely coupled areas of code. I want to be able to work through the problem of wanting to change a module, but not knowing exactly what will break if I do change it, which other libs have a dependency on the module, with incoming dependencies across files grouped and counted by quantity, to help understand what files are depended on most. Next I want to figure out a minimal interface. So I would like the software to be able to output a set of data that can be processed by an LLM to determine what the right interface is. This means outputting a prompt? Here are the usage steps: generate a graph from a codebase that meets this basic criteria (typescript, with apps/libs dirs, this could be pre-configurable or parameter configurable) and save as JSON. Take that JSON and upload into this dependency graph tool. Then render a graph in D3 with informational panels that show all the info. However it is very important that the tool allow smooth and visual representations of the dependencies and let me go in/out of subtrees of dependencies to explore something. It should be smooth.
 
So more specifically, I want to be able to examine a codebase structure as a graph with different sizes, colors, styles, etc based on the quantity/grouping of the file/vertex, and weights/breakdowns of each import/edge.  For example: if 3 files depend on file A with the same import/reference, then they would get grouped together as 3. And if 1 file depended on file B with a different import/reference, it would be grouped separately and be "smaller" (either visually or with a count) than the import with 3. Workflow idea: open a graph JSON in the app, see the graph rendered on screen. See the main apps and libs represented as one main app that has many internal modules, and libs as each one being the root of a collection of code. Then I want to explore it - 
 
Ideally I want two ways of "zooming" in: focused on a module where there is basically a "go one level deeper on import graph while keeping this thing in focus" or when selecting anything else or not having anything selected and just zooming in/out with the scrollwheel. How does selecting and going a level deeper? Seems like there needs to be a couple actions: click on a vertex, click on an edge. When clicking on a vertex, I want to know what is importing from this, what it is importing from, and I want to see those things highlighted as vertices/nodes. In the next set of features, I will want to see those node's imports (things depending on it and things it depends on) probably by doing some sort of "zoom" thing to show a higher level of detail - one "unit of zoom" for each level of modules and imports, but for now I will leave it. When I click on an edge or an import reference (it will be showing an import name/filepath with a counter showing how many references, no counter if its 1). There is no need for a special zoom when selecting an edge. Zoom should do normal zoom in/out when nothing is selected.
 
I want the ability to get an all-up view of everything calling into a single module. Basically the goal here is to understand what the tightest scoped interface I can create it. There may be UI components or services. I want to know where its used in each file. Then I want a deep-link to that file to my IDE (probably Cursor or VS Code using `vscode://` or I could send it to github file link).

Tool needs to be able to be able to help extract an interface from an edge or a set of edges. There could be a select mode where you pick multiple edges from different modules in order to build an interface. For example: if there are multiple modules that all implement similar things, I would want to select all of them and then say "extract interface" and then it would pop up a suggestion with a set of interfaces based on the things being called, and even if the interface is just a de-duped listing of all the functions in common and unique-to-a-module, that’s fine. 

So it goes: from a clean dependency graph view, select first the module that is the "importer" - the thing that imports from all of the other modules, and then the 2nd through N selected modules with multi-select (shift-select?) where all the rest are the modules that are depended on and have things imported from into the importer module. Note: this might be useful for a single file too, but start with module first. Then after selecting, all of their imports in and out will be highlighted. There should be a layer control that can toggle imports, imported by, or both – default should be both. So basically I select a module node that has things it depends on. Here's an example: let's say it’s a feature that has several different providers of functionality, all which follow *similar* interfaces, but are not strongly enforced or grouped cleanly/dynamically. I would want to extract a common interface from this group of upstream modules so that I can see what is the intersection of all their behavior. Now this could be either programmatically determined with sets, or evaluated with an LLM. First start with just a pure intersection, then let's do the LLM integration later.

I want to extract similar providers, shared components/services, and start to define libraries by the type of lib it is (what kind of provider, is it just stateless functional code that helps perform logic, is it a 3rd party integration, is it a 1st party integration, is it a custom integration or does it follow a core set of functionality/APIs with an interface). All useful things to think about here and to help bucket up the behavior. At the end of the day, I want a view into how each module and file is used, and what each module/file is using.
